---
title: "用go给C++写库"
date: 2024-06-28T11:25:41+08:00
draft: false
tags: ['golang', 'AES']
---

## 缘起

一个C++项目需要与Java后台通信，通信数据需要用AES加解密。

这个需求对于Java来说极其简单，只需要用jre里的标准算法即可：
```java
public static byte[] AES_256_ecb_encrypt(byte[] input, byte[] byteKey) throws NoSuchPaddingException, NoSuchAlgorithmException, InvalidKeyException, BadPaddingException, IllegalBlockSizeException {
      Cipher cipher = Cipher.getInstance("AES/ECB/PKCS5Padding");
      SecretKey key = new SecretKeySpec(byteKey, "AES");
      cipher.init(Cipher.ENCRYPT_MODE, key);
      byte[] encrypted = cipher.doFinal(input);
      return encrypted;
  }
 
  public static byte[] AES_256_ecb_decrypt(byte[] input, byte[] byteKey) throws NoSuchPaddingException, NoSuchAlgorithmException, InvalidKeyException, BadPaddingException, IllegalBlockSizeException {
      Cipher cipher = Cipher.getInstance("AES/ECB/PKCS5Padding");
      SecretKey key = new SecretKeySpec(byteKey, "AES");
      cipher.init(Cipher.DECRYPT_MODE, key);
      byte[] decrypted = cipher.doFinal(input);
      return decrypted;
  }
```

基本上只需要修改上面的字符串，就可以调用AES算法的CBC/ECB等，也可以修改补码方式，比如ZERO/PKCS5Padding等。而同样的事情到了C++这边就麻烦了。

大家的做法都是编译`OpenSSl`，并调用该库的函数来实现。确实这样可以，但这个库在windows下太难编译了，而且我的程序还要在linux下运行，所以我想找一份简单的代码，能够直接集成到项目里，到时候在不同的平台编译就可以了。

一开始找的是[tiny-AES-c](https://github.com/kokke/tiny-AES-c)，这个库用ECB算法，可以与java端对上，可以加解密。但ECB算法是每16个字节进行一次编码，这样会导致：当你的加密内容有一部分不变，而另一部分是变化的时候（打个比方，加密内容为：用户名+登录时间戳，用户名就是不变的，而时间戳随时在变），加密出来的内容也是一部分在变，另一部分则永远不变。这样很容易让人猜出来你的加密方法。AES-CBC算法虽然也是每16字节编码一次，但它会将当前16字节与前16字节的编码结果进行异或处理，这样就可以保证加密内容里不变的部分，也会每次变化，可以提高安全性（参考：[AES高级加密的工作模式（ECB、CBC、CFB、OFB）](https://cloud.tencent.com/developer/article/1931837)），所以想着用CBC替换掉ECB。其实tiny-AES-c这个库从代码上来看是支持CBC的，但padding部分没有提供PKCS5Padding的实现，要想与java一致，这部分还要自己写。而我刚接触这个算法，一开始没太明白padding的原理，所以试了半天也没实现与java互通。

恰巧学习了golang，它的标准库里包含了AES算法，所以想着用golang编写一个小exe，它只负责根据输入的密钥、IV、密文进行加解密，再将结果输出，C++只负责调用这个exe就可以了。网上搜了一下，golang居然直接支持编译成动态库，这样C++可以直接集成了！

说干就干，网上随便找了份AES/CBC的代码，测试了一下可以与java互通加解密：
```golang
import (
	"C"
	"bytes"
	"crypto/aes"
	"crypto/cipher"
	"encoding/base64"
)

/*
key参数的长度 iv必须相同长度
16 字节 - AES-128
24 字节 - AES-192
32 字节 - AES-256
*/
func EncryptAES_CBC(src, key, iv string) string {
	data := []byte(src)
	keyByte := []byte(key)
	block, err := aes.NewCipher(keyByte)
	if err != nil {
		fmt.Println("EncryptAES_CBC:", src, key, iv)
		panic(err)
	}
	data = PKCS5Padding(data, block.BlockSize())
	//获取CBC加密模式
	ivByte := []byte(iv)
	mode := cipher.NewCBCEncrypter(block, ivByte)
	out := make([]byte, len(data))
	mode.CryptBlocks(out, data)
	return base64.StdEncoding.EncodeToString(out)
}

// AES CBC解密
func DecryptAES_CBC(src, key, iv string) string {
	keyByte := []byte(key)
	data, err := base64.StdEncoding.DecodeString(src)
	if err != nil {
		panic(err)
	}
	block, err := aes.NewCipher(keyByte)
	if err != nil {
		panic(err)
	}
	//iv := keyByte //用密钥作为向量(不建议这样使用)
	ivBye := []byte(iv)
	mode := cipher.NewCBCDecrypter(block, ivBye)
	plaintext := make([]byte, len(data))
	mode.CryptBlocks(plaintext, data)
	plaintext = PKCS5UnPadding(plaintext)
	return string(plaintext)
}

// 明文补码算法
func PKCS5Padding(ciphertext []byte, blockSize int) []byte {
	padding := blockSize - len(ciphertext)%blockSize
	padtext := bytes.Repeat([]byte{byte(padding)}, padding)
	return append(ciphertext, padtext...)
}

// 明文减码算法
func PKCS5UnPadding(origData []byte) []byte {
	length := len(origData)
	unpadding := int(origData[length-1])
	return origData[:(length - unpadding)]
}

func main() {
  if len(os.Args) != 3 {
		return
	}
	
	src_txt := os.Args[2]
	switch os.Args[1] {
	case "0": //加密
		data, err := base64.StdEncoding.DecodeString(src_txt)
		if err != nil {
			panic(err)
		}
		fmt.Print(EncryptAES_CBC(string(data), aesKey, aesIv))
	
	case "1": //解密
		fmt.Print(DecryptAES_CBC(src_txt, aesKey, aesIv))
	}
}
```

下一步就是编译dll，按着[网上说的](https://www.cnblogs.com/quchunhui/p/16963248.html)，增加了两个函数：
```golang
//export Encrypt
func Encrypt(src, key, iv *C.char) *C.char {
	g_src := C.GoString(src)
	g_key := C.GoString(key)
	g_iv := C.GoString(iv)

	return C.CString(EncryptAES_CBC(g_src, g_key, g_iv))
}

//export Decrypt
func Decrypt(src, key, iv *C.char) *C.char {
	g_src := C.GoString(src)
	g_key := C.GoString(key)
	g_iv := C.GoString(iv)

	return C.CString(DecryptAES_CBC(g_src, g_key, g_iv))
}
```

这里为了方便起见，把所有出入的参数都换成了C的类型，方便C++调用。然后生成dll：
```shell
# 生成动态库
go build -buildmode=c-shared -o crypto.dll .\main.go

# 还可以生成静态库
go build -buildmode=c-archive -o crypto.lib .\main.go
```

不出意外的话，就能得到.h和.dll文件了，大致看下.h：
```c++
/* Code generated by cmd/cgo; DO NOT EDIT. */

#line 1 "cgo-builtin-export-prolog"

#include <stddef.h>

#ifndef GO_CGO_EXPORT_PROLOGUE_H
#define GO_CGO_EXPORT_PROLOGUE_H

/*
 * 中间部分没啥用，略
 */

#ifdef __cplusplus
extern "C" {
#endif

extern __declspec(dllexport) char* Encrypt(char* src, char* key, char* iv);
extern __declspec(dllexport) char* Decrypt(char* src, char* key, char* iv);

#ifdef __cplusplus
}
#endif 
```

看着还真是不错啊，基本跟手写的C++导出函数一模一样，不错！

下一步就是C++调用了，因为没有.lib文件，所以要用到LoadLibrary（网上也有[生成.lib的方法](https://blog.csdn.net/weixin_43294620/article/details/130727194)，懒得整），具体方法：
```c++
#include "crypto.h"

typedef char* (*pEncrypt)(char* src, char* key, char* iv);
typedef char* (*pDecrypt)(char* src, char* key, char* iv);

int main()
{
  HMODULE h = ::LoadLibraryA("path/to/crypto.dll");
  if (NULL == h || INVALID_HANDLE_VALUE == h)
  {
      qDebug() << "load crypto.dll failed：";
      return -1;
  }

  pEncrypt encrypt = (pEncrypt)GetProcAddress(h, "Encrypt");
  pDecrypt decrypt = (pDecrypt)GetProcAddress(h, "Decrypt");

  QString src = "abcdef";
  QString iv = "1234567812345678";

  char* encrypt_txt = Encrypt((char*)src.toStdString().c_str(), (char*)key.c_str(), (char*)iv.c_str());
  qDebug() << encrypt_txt;

  char* decrypt_txt = Decrypt((char*)encrypt_txt, (char*)key.c_str(), (char*)iv.c_str());
  qDebug() << decrypt_txt;

  return 0;
}
```

过程就跟调用一般的C++dll没啥区别。

用这种方法，那C++就可以借用golang的标准库和生态，可以极大的扩展C++的能力，让C++具有以往很麻烦才能实现的能力。